
void Renderer::floodFill(VEC2 & v, const Color & c)
{
	uint32_t* pixel = &frameBuffer[((uint32_t)v.SSE_VEC[0]) + ((uint32_t)v.SSE_VEC[1])*scrWidth];
	if ((*pixel) != c.colorVal) *pixel = c.colorVal;

	//flood fill is done under 4 functions each functions operate with certain loops over the pixels 
	//why not recursion ? 
	//1-yes recursion is easier to implement but will be a  bit slower
	//2-if its a big triangle program might crash due to stack overflow

	//USE THREADS ?
	//std::thread t1(&Renderer::floodFillUp, this, std::ref(v), std::ref(c));
	//std::thread t2(&Renderer::floodFillDown, this, std::ref(v), std::ref(c));
	floodFillUp(v,c);//fills up line-up right sector -up left sector
	floodFillDown(v, c);//fills down line-down right sector -down left sector
	floodFillLeft(v, c);//fills left line
	floodFillRight(v, c);//fills right line
	//JOIN THREADS ?
	//t2.join();
	//t1.join();
}

void Renderer::floodFillRight(VEC2 & v, const Color & c)//check right and right up
{
	uint32_t* pixel = &frameBuffer[((uint32_t)v.SSE_VEC[0]) + ((uint32_t)v.SSE_VEC[1])*scrWidth];
	while ((*++pixel) != c.colorVal) {
		*pixel = c.colorVal;
	}
}

void Renderer::floodFillLeft(VEC2 & v, const Color & c)//check left - left up - left down
{
	uint32_t* pixel = &frameBuffer[((uint32_t)v.SSE_VEC[0]) + ((uint32_t)v.SSE_VEC[1])*scrWidth];
	while ((*--pixel) != c.colorVal) {
		*pixel = c.colorVal;
	}
}

void Renderer::floodFillUp(VEC2 & v, const Color & c)
{
	uint32_t* pixel = &frameBuffer[((uint32_t)v.SSE_VEC[0]) + ((uint32_t)v.SSE_VEC[1])*scrWidth];
	//Y AXIS INVERTED IN THE SCREEN VIEW
	pixel = pixel - scrWidth;//Start from vertex exactly above selected vertex
	for (; (*pixel) != c.colorVal; pixel -= scrWidth) {
		*(pixel) = c.colorVal;
		//+ve x axis
		for (uint32_t j = 1;; j++) {
			if (*(pixel + j) == c.colorVal) break;
				*(pixel + j) = c.colorVal;
		}
		//-ve x axis
		for (uint32_t j = 1;; j++) {
			if (*(pixel - j) == c.colorVal) break;
				*(pixel - j) = c.colorVal;
		}
	}
}

void Renderer::floodFillDown(VEC2 & v, const Color & c)
{
	uint32_t* pixel = &frameBuffer[((uint32_t)v.SSE_VEC[0]) + ((uint32_t)v.SSE_VEC[1])*scrWidth];
	//Y AXIS INVERTED IN THE SCREEN VIEW
	pixel = pixel + scrWidth;//Start from vertex exactly under selected vertex
	for (; (*pixel) != c.colorVal; pixel += scrWidth) {
		*(pixel) = c.colorVal;
		//+ve x axis
		for (uint32_t j = 1;; j++) {
			if (*(pixel + j) == c.colorVal) break;
				*(pixel + j) = c.colorVal;
		}
		//-ve x axis
		for (uint32_t j = 1;; j++) {
			if (*(pixel - j) == c.colorVal) break;
				*(pixel - j) = c.colorVal;
		}
	}
}